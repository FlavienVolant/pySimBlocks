import re
import inspect
from pathlib import Path
from multiprocessing import Process, Pipe
import importlib.util

from pySimBlocks.generate.generate_parameters import generate_parameters
from pySimBlocks.generate.generate_model import resolve_block_import

# =============================================================================
#
# =============================================================================
def normalize_block_for_controller(block):
    """
    Force SofaPlant → SofaExchangeIO for controller generation.
    Both share 'input_keys' and 'output_keys'.
    """
    if block["type"].lower() == "sofa_plant":
        return {
            "name": block["name"],
            "type": "sofa_exchange_i_o",
            "from": "systems",
            "input_keys": block["input_keys"],
            "output_keys": block["output_keys"],
        }
    return block



def _load_scene_in_subprocess(scene_path, conn):
    """
    Load Sofa Scene in subprocess, get path file from controller.
    """
    try:

        spec = importlib.util.spec_from_file_location("scene", scene_path)
        mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(mod)

        import Sofa
        root = Sofa.Core.Node("root")

        # Appel createScene() → doit retourner root, controller
        out = mod.createScene(root)
        if not isinstance(out, (list, tuple)) or len(out) < 2:
            conn.send(None)
            return

        controller = out[1]
        controller_file = inspect.getsourcefile(controller.__class__)

        conn.send(controller_file)

    except Exception:
        conn.send(None)

    finally:
        conn.close()


def detect_controller_file_from_scene(scene_file):
    """
    Automatically get controller path from scene.
    """
    parent_conn, child_conn = Pipe()

    p = Process(target=_load_scene_in_subprocess, args=(scene_file, child_conn))
    p.start()
    controller_path = parent_conn.recv()
    p.join()

    if controller_path is None:
        raise RuntimeError(
            f"Unable to determine controller file from scene {scene_file}. "
            "Ensure createScene(root) returns (root, controller)."
        )

    return Path(controller_path)


# =============================================================================
#
# =============================================================================
def remove_build_model_function(text):
    lines = text.split("\n")

    start = None
    indent = None

    # Trouver la ligne def build_model
    for i, line in enumerate(lines):
        stripped = line.lstrip()
        if stripped.startswith("def build_model"):
            start = i
            indent = len(line) - len(stripped)
            break

    if start is None:
        return text

    # Trouver la fin du bloc
    end = start + 1
    for j in range(start + 1, len(lines)):
        line = lines[j]
        if not line.strip():
            continue
        current_indent = len(line) - len(line.lstrip())
        if current_indent <= indent:
            end = j
            break
    else:
        end = len(lines)

    # Supprimer lignes vides ou indentées restant après la fonction
    while end < len(lines) and (not lines[end].strip() or len(lines[end]) - len(lines[end].lstrip()) > indent):
        end += 1

    new_lines = lines[:start] + lines[end:]
    return "\n".join(new_lines)


# =============================================================================
#
# =============================================================================
def build_instantiation_line(block):
    name = block["name"]
    module, class_name = resolve_block_import(block["from"], block["type"])

    params = {
        k: f"{name}_{k}"
        for k in block.keys()
        if k not in ("name", "type", "from")
    }

    if params:
        pstr = ", ".join(f"{k}={v}" for k, v in params.items())
        return f'self.{name} = {class_name}("{name}", {pstr})'

    return f'self.{name} = {class_name}("{name}")'


def generate_build_model_code(blocks, connections, logs):
    indent = " " * 4
    lines = []

    lines.append(f"{indent}def build_model(self):")
    lines.append("")

    for blk in blocks:
        lines.append(f"{indent*2}{build_instantiation_line(blk)}")

    lines.append("")
    lines.append(f'{indent*2}self.model = Model("sofa_autogenerated_controller")')
    lines.append(f"{indent*2}for blk in [")

    for blk in blocks:
        lines.append(f"{indent*3}self.{blk['name']},")

    lines.append(f"{indent*2}]:")
    lines.append(f"{indent*3}self.model.add_block(blk)")
    lines.append("")

    lines.append(f"{indent*2}# Connections")
    for src_full, dst_full in connections:
        src, outp = src_full.split(".")
        dst, inp = dst_full.split(".")
        lines.append(f'{indent*2}self.model.connect("{src}", "{outp}", "{dst}", "{inp}")')

    logs_str = ", ".join(f'"{l}"' for l in logs)
    lines.append("")
    lines.append(f"{indent*2}self.variables_to_log = [{logs_str}]")
    lines.append("")

    return "\n".join(lines)


# =============================================================================
#
# =============================================================================
def inject_build_model(controller_path, build_model_code, required_imports):
    path = Path(controller_path)
    text = path.read_text()

    # Ajouter imports
    for imp in required_imports:
        if imp not in text:
            text = imp + "\n" + text

    # Supprimer ancien build_model()
    text = remove_build_model_function(text)

    # Trouver fin de la classe héritant de SofaPysimBlocksController
    class_pattern = r"class\s+(\w+)\s*\(\s*SofaPysimBlocksController\s*\)\s*:"
    match = re.search(class_pattern, text)
    if not match:
        raise RuntimeError("No class inheriting SofaPysimBlocksController found.")

    class_start = match.end()
    next_class = re.search(r"\nclass\s+", text[class_start:])
    class_end = class_start + (next_class.start() if next_class else len(text) - class_start)

    insertion = "\n" + build_model_code + "\n"
    new_text = text[:class_end] + insertion + text[class_end:]

    return new_text




# =============================================================================
# MAIN
# =============================================================================
def generate_sofa_controller(blocks, connections, simulation, dry_run=False):
    """
    - If SofaPlant → load scene and find
    - If SofaExchangeIO → use field YAML `controller_file`.
    """

    # 1. Identifier le bloc SofaPlant ou SofaExchangeIO
    sofa_block = next((b for b in blocks if b["type"].lower() in ("sofa_plant", "sofa_exchange_i_o")), None)

    if sofa_block is None:
        raise RuntimeError("No SofaPlant or SofaExchangeIO block found in project.")

    # 2. Si path explicite fourni par --sofa, override
    # Cas SofaPlant → détection automatique
    if sofa_block["type"].lower() == "sofa_plant":
        scene_file = Path(sofa_block["scene_file"])
        controller_file = detect_controller_file_from_scene(scene_file)

    # Cas SofaExchangeIO → nécessite un champ YAML
    else:
        if "controller_file" not in sofa_block:
            raise RuntimeError(
                "SofaExchangeIO block requires a `controller_file:` entry "
                "to enable automatic controller generation."
            )
        controller_file = Path(sofa_block["controller_file"])

    blocks = [normalize_block_for_controller(b) for b in blocks]

    # 3. Générer parameters_auto.py dans le même dossier que le controller
    controller_dir = controller_file.parent
    params_path = controller_dir / "parameters_auto.py"
    params_src = generate_parameters(blocks, simulation)
    params_txt = "\n".join(params_src)
    if dry_run:
        print("\n----- DRY RUN PARAMETERS_AUTO.PY (no changes written) -----")
        print(params_txt)
    else:
        params_path.write_text(params_txt)
        print(f"[OK] parameters_auto.py written to {params_path}")

    # 4. Imports requis
    required_imports = {"from parameters_auto import *", "from pySimBlocks import Model"}
    for blk in blocks:
        module, class_name = resolve_block_import(blk["from"], blk["type"])
        required_imports.add(f"from {module} import {class_name}")

    # 5. Générer build_model()
    logs = simulation.get("log", [])
    build_model_code = generate_build_model_code(blocks, connections, logs)

    # 6. Mise à jour du controller
    new_text = inject_build_model(controller_file, build_model_code, required_imports)

    if dry_run:
        print("\n----- DRY RUN SOFA CONTROLLER (no changes written) -----")
        print(new_text)
    else:
        controller_file.write_text(new_text)
        print(f"[OK] Updated controller with auto-generated build_model(): {controller_file}")
