from pySimBlocks import Model
from pySimBlocks.blocks.sources.constant import Constant
from pySimBlocks.blocks.systems.sofa.sofa_exchange_i_o import SofaExchangeIO
from parameters_auto import *
from pySimBlocks.blocks.operators.gain import Gain
from pySimBlocks.blocks.operators.sum import Sum
from pySimBlocks.blocks.sources.step import Step
from pySimBlocks.blocks.operators.discrete_integrator import DiscreteIntegrator
import numpy as np
from pySimBlocks.blocks.systems.sofa import SofaPysimBlocksController

import Sofa


class FingerController(SofaPysimBlocksController):

    def __init__(self, root, actuator, mo, tip_index=121, name="FingerController"):
        super().__init__(name=name)

        self.mo = mo
        self.actuator = actuator
        self.tip_index = tip_index
        self.dt = root.dt.value
        self.verbose = True

        # Inputs & outputs dictionaries
        self.inputs = { "cable": None }
        self.outputs = { "tip": None, "measure": None }


    def get_outputs(self):
        tip = self.mo.position[self.tip_index].copy()
        self.outputs["tip"] = np.asarray(tip).reshape(-1, 1)
        self.outputs["measure"] = np.asarray(tip[1]).reshape(-1, 1)

    def set_inputs(self):
        # 1. READ INPUT -------------------------------------
        val = self.inputs["cable"]

        # Safe default for first initialization call
        if val is None:
            # ↓↓↓ Valeur par défaut pour l’initialisation
            val = 0.0

        # Convert input to Sofa format
        if isinstance(val, np.ndarray):
            processed = val.flatten().tolist()
        elif isinstance(val, (list, tuple)):
            processed = val
        else:
            processed = [float(val)]

        # Apply to actuator
        self.actuator.value = processed

    def build_model(self):

        self.step = Step("step", value_before=step_value_before, value_after=step_value_after, start_time=step_start_time)
        self.error = Sum("error", num_inputs=error_num_inputs, signs=error_signs)
        self.Kp = Gain("Kp", gain=Kp_gain)
        self.Ki = Gain("Ki", gain=Ki_gain)
        self.discrete_integrator = DiscreteIntegrator("discrete_integrator", initial_state=discrete_integrator_initial_state)
        self.sum = Sum("sum", num_inputs=sum_num_inputs)
        self.sofa = SofaExchangeIO("sofa", input_keys=sofa_input_keys, output_keys=sofa_output_keys)

        self.model = Model("sofa_autogenerated_controller")
        for blk in [
            self.step,
            self.error,
            self.Kp,
            self.Ki,
            self.discrete_integrator,
            self.sum,
            self.sofa,
        ]:
            self.model.add_block(blk)

        # Connections
        self.model.connect("step", "out", "error", "in1")
        self.model.connect("error", "out", "Kp", "in")
        self.model.connect("error", "out", "discrete_integrator", "in")
        self.model.connect("Kp", "out", "sum", "in1")
        self.model.connect("discrete_integrator", "out", "Ki", "in")
        self.model.connect("Ki", "out", "sum", "in2")
        self.model.connect("sum", "out", "sofa", "cable")
        self.model.connect("sofa", "measure", "error", "in2")

        self.variables_to_log = ["step.outputs.out", "sofa.outputs.measure", "sum.outputs.out"]

